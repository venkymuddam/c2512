

58. User defined string copy function.
    a user-defined string copy function to manually copy the contents of one string to another. 
    This is useful when you want to control how the copy operation works, as opposed to relying on the built-in strcpy() function from the C Standard Library.


59. Oops- brief idea about all the subtopics.

60. Virtual Function Coding

        #include <iostream>
        using namespace std;
        // Base class
        class Shape {
        public:
            // Declare a virtual function
            virtual void draw() {
                cout << "Drawing Shape" << endl;
            }
        };

        // Derived class 1
        class Circle : public Shape {
        public:
            // Override the virtual function
            void draw() override {
                cout << "Drawing Circle" << endl;
            }
        };

        // Derived class 2
        class Square : public Shape {
        public:
            // Override the virtual function
            void draw() override {
                cout << "Drawing Square" << endl;
            }
        };

        int main() {
            // Create objects of derived classes
            Shape* shape1 = new Circle();
            Shape* shape2 = new Square();
        }



61      Make a dynamic array and add elements using pointer to array.

        #include <iostream>
        using namespace std;

        int main() {
            int n;  // Size of the array

            // Ask user for the size of the array
            cout << "Enter the number of elements: ";
            cin >> n;

            // Create a dynamic array using a pointer
            int* arr = new int[n];  // Allocate memory for 'n' integers

            // Input elements into the array using pointer arithmetic
            cout << "Enter " << n << " elements:" << endl;
            for (int i = 0; i < n; ++i) {
                cout << "Element " << i + 1 << ": ";
                cin >> *(arr + i);  // Access elements using pointer
            }

            // Display the elements of the array using pointer
            cout << "The entered elements are: ";
            for (int i = 0; i < n; ++i) {
                cout << *(arr + i) << " ";  // Access elements using pointer
            }
            cout << endl;

            // Free the dynamically allocated memory
            delete[] arr;

            return 0;
        }


62. Pointer- Explanation
    Pointer is a variable that stores the memory address of another variable.
    Efficient Memory Access: Pointers provide a way to access and manipulate memory directly.
    Dynamic Memory Allocation: Using pointers, you can allocate memory dynamically during runtime.
    
    A pointer is declared using the * operator.
    int *ptr; 
    Dereferencing:
    we can access the value stored at the memory location pointed to by the pointer using the * operator (dereference operator).
    cout << *ptr;

    1. Null Pointer
    A pointer that doesn't point to any memory location.
    It can be used for Dynamic Memory Allocation

    Dangling Pointer: Accessing memory that has been freed.
    A dangling pointer is a pointer that refers to a memory location that has already been deallocated (freed) or is out of scope

    Memory Leak: Forgetting to free dynamically allocated memory.

63. Access Specifiers 
        1. Public
            Members declared as public are accessible from anywhere in the program.
            There are no restrictions on access.
        2. Private
            Members declared as private are accessible only within the class in which they are defined.
            They cannot be accessed directly from outside the class.
        3.Protected
            Members declared as protected are accessible:
            Within the class where they are defined.
            In derived classes (through inheritance).
            This is typically used to allow access to derived classes while restricting access from the outside world.



64. Run time polymorphism coding
    Polymorphism enables methods to behave differently 
    based on the type of object they are acting on, 
    The term polymorphism means "many forms," and 
    it refers to the ability of one function, method, or operator 
    to work in multiple ways depending on the context.
    polymorphism allows you to perform a single action in different ways.


65. Did u study threading, sockets? 
    Multithreading is a programming technique that allows a program to perform multiple tasks concurrently 
    by dividing its execution into smaller units called threads. 
    Each thread runs independently, 
    Thread
    A thread is the smallest unit of a program that can execute independently. A single program can contain multiple threads, all sharing the program's resources 
    (e.g., memory).

    Main Thread
    Every program starts with a main thread. In multithreading, additional threads are spawned alongside the main thread.

    Concurrency vs. Parallelism

    Concurrency: Multiple threads make progress independently but may not execute simultaneously (e.g., time-slicing).
    Parallelism: Threads execute simultaneously on multiple CPU cores.

    Advantages
    Improved Performance: Tasks are divided and executed in parallel.
    Resource Sharing:

    Challenges in Multithreading
    Race Conditions: Occurs when multiple threads access and modify shared resources simultaneously.
    Deadlocks: Happens when two or more threads are waiting indefinitely for each other to release resources.
    Context Switching: Overhead caused by switching between threads.
    Thread Safety: Ensuring shared data is accessed in a controlled manner.


66. How was the training in both Phase 1 and Phase 2?
67. Which phase did you like most? Why?
68. What topics did you learn during these two phases?
69. What is OOPs, and why is it needed?

Object-Oriented Programming (OOP) is a programming paradigm based on the concept of objects, which are instances of classes. 
It focuses on organizing code into reusable and modular components by modeling real-world entities using classes and objects.

Class
A blueprint or template for creating objects.
Defines properties (data members) and methods (member functions).
   
Object
An instance of a class.
Represents a specific entity with properties and behaviors.

Encapsulation:
Bundling data (variables) and methods (functions) into a single unit (class).
Achieved through access specifiers like private, public, and protected.

Inheritance
Mechanism where one class derives properties and behavior from another class.
Promotes code reuse.

Polymorphism
The ability of a function or method to behave differently based on the context.
Types: Compile-time polymorphism (method overloading) and Run-time polymorphism (method overriding).

Abstraction
Hiding unnecessary implementation details from the user and showing only essential features.
Achieved using abstract classes or interfaces.

Encapsulation : Bundling data (variables) and methods (functions) into a single unit (class).
Achieved through access specifiers like private, public, and protected.


class Shape {
public:
    virtual void draw() = 0; // Pure virtual function
};

class Circle : public Shape {
public:
    void draw() override { cout << "Drawing Circle" << endl; }
};


Why is OOP Needed?
    Modularity : Code is organized into classes, making it modular and easier to manage.
    Reusability : Inheritance allows developers to reuse existing code, reducing redundancy.
    Maintainability : Encapsulation ensures that changes in one part of the code do not affect others, making programs easier to maintain.
    Scalability : OOP makes it easier to add new features without affecting existing code.
    Security : Encapsulation and abstraction protect sensitive data by restricting access to it.

70. What is the difference between stack and heap?
		
Stack	Used for static memory allocation and managing function call execution (e.g., local variables, function parameters).	
        Memory is allocated automatically when a function is called and deallocated when the function exits.
        Faster because it uses Last In, First Out (LIFO) structure.

        Memory is automatically reclaimed when the function or block scope ends.
        Memory is limited to the block in which it is declared.
        	cpp int x = 10; (local variable on the stack)
            Managed automatically by the operating system.
    
Heap    Used for dynamic memory allocation, where memory is allocated and freed manually by the programmer or automatically by a garbage collector.
        Memory is allocated and deallocated manually using new/delete (C++), malloc/free (C), or automatically via garbage collection (e.g., Java).
    	Slower due to manual memory management and potential fragmentation.
        Memory remains allocated until explicitly freed or the program ends.
        Memory can be accessed globally if a pointer/reference is passed.
        cpp int* p = new int[10]; (dynamic array on the heap)
        Managed manually by the programmer. Memory leaks and fragmentation can occur if memory is not freed properly.


71. What is the difference between structure and class?

Feature	                            Structure (struct)	                                                                Class (class)
Default Access Modifier	             Members are public by default.	                                            Members are private by default.
Purpose                 	Originally designed for grouping related data.	                                        Designed to model both data and behavior (OOP paradigm).
Encapsulation	            Can have encapsulation but requires explicitly setting private or protected access.	    Strongly supports encapsulation with default private members.
Constructors/Destructors	In modern C++ (from C++11 onwards), struct can have constructors and destructors.	    Fully supports constructors, destructors, and member functions.
Intended Use	            Generally used for  small data aggregates.	                                          Used for more complex data structures and to implement OOP features.


72. Write the syntax of the new operator.
    new operator is used to dynamically allocate memory for objects or variables on the heap. 

    int* ptr = new int;  // Allocates memory for one integer

    *ptr = 42;  

    int* arr = new int[5];  // Allocates memory for an array of 5 integers
    arr[0] = 10;           // Assign values
    arr[1] = 20;

    MyClass* obj = new MyClass;  // Allocates memory for an object
    obj->data = 42; 

    also want to delete the memory
    delete ptr; 

73. Array sorting

    The std::sort function is defined in the <algorithm> header. It sorts elements in **ascending
    order by default and can be customized for descending or other orders using a comparator function.
    
    #include <algorithm> // For std::sort
    #include <iostream>
    std::sort(start_iterator, end_iterator);


    #include <iostream>
    #include <algorithm> // For std::sort

    int main() {
        int arr[] = {5, 2, 9, 1, 5, 6};
        int n = sizeof(arr) / sizeof(arr[0]); // Calculate array size

        // Sort in ascending order
        std::sort(arr, arr + n);

        // Display sorted array
        std::cout << "Sorted array: ";
        for (int i = 0; i < n; ++i) {
            std::cout << arr[i] << " ";
        }

        return 0;
    }


74. Adding an element in the middle of the array
        In C++, arrays have a fixed size, meaning that once they are declared, the size cannot be changed. 

        Create a new array with a size larger than the original array.
        Shift elements of the original array to make space for the new element.
        Insert the new element in the desired position.

        #include <iostream>
        using namespace std;

        int main() {
            int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; // Original array of size 9
            int n = 9;  // Current size of the array
            int k = 4;  // Position where the new element should be added
            int newElement = 100; // The element to insert

        if (n < 10) {
            // Shift elements to the right to make space for the new element
            for (int i = n; i > k; --i) {
                arr[i] = arr[i - 1];
            }

            // Insert the new element at position k
            arr[k] = newElement;

            // Increase the size of the array
            n++;

            // Display the updated array
            cout << "Updated array: ";
            for (int i = 0; i < n; ++i) {
                cout << arr[i] << " ";
            }
        } else {
            cout << "Array is full, cannot insert element!" << endl;
        }

        return 0;
    }


75. Operator overloading

    Operator Overloading in C++ allows you to redefine the way operators work for user-defined types (like classes and structures). 
    By overloading operators, you can give them custom behavior when they are applied to objects of your classes, enhancing the flexibility of your code.
    Define a function using the keyword operator followed by the symbol of the operator.
    syntax  --    ReturnType operator+(Parameters);

    Only existing operators can be overloaded. You cannot create new operators.
    Certain operators cannot be overloaded (e.g., ::, sizeof, .*, .*, and ?:).

    Unary Operators: Overloaded for operations like -, ++, or --.
    Binary Operators: Overloaded for operations like +, -, *, or /.
    Relational Operators: Overloaded for comparisons (<, >, ==, etc.).

    #include <iostream>
    using namespace std;

    class Complex {
    private:
        float real, imag;

    public:
        Complex(float r = 0, float i = 0) : real(r), imag(i) {}

        // Overload the + operator
        Complex operator+(const Complex& other) {
            return Complex(real + other.real, imag + other.imag);
        }

        void display() {
            cout << real << " + " << imag << "i" << endl;
        }
    };

    int main() {
        Complex c1(3.0, 4.0), c2(1.5, 2.5);
        Complex c3 = c1 + c2; // Use overloaded +
        c3.display(); // Output: 4.5 + 6.5i
        return 0;
    }


76. Create a class Student and an array of objects


        #include <iostream>
        #include <string>
        using namespace std;

        // Define the Student class
        class Student {
        private:
            string name;
            int rollNo;
            float marks;

        public:
            // Constructor to initialize a student object
            Student(string n = "", int r = 0, float m = 0.0) : name(n), rollNo(r), marks(m) {}

            // Function to set the details of a student
            void setDetails(string n, int r, float m) {
                name = n;
                rollNo = r;
                marks = m;
            }

            // Function to display the details of a student
            void displayDetails() {
                cout << "Name: " << name << ", Roll No: " << rollNo << ", Marks: " << marks << endl;
            }
        };

        int main() {
            const int SIZE = 3; // Number of students
            Student students[SIZE]; // Array of Student objects

            // Setting details for each student
            students[0].setDetails("Alice", 101, 85.5);
            students[1].setDetails("Bob", 102, 90.0);
            students[2].setDetails("Charlie", 103, 88.0);

            // Displaying details of each student
            cout << "Student Details:" << endl;
            for (int i = 0; i < SIZE; i++) {
                students[i].displayDetails();
            }

            return 0;
        }
